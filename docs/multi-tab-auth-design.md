# 多标签页同时过期认证设计

## 问题场景

**第一天**：用户打开 app.com、bpp.com、cpp.com，都完成登录

**第二天**：浏览器恢复 3 个标签页，Session 都过期了

**当前行为**：3 个标签页同时跳转到 Logto，用户不知道该怎么办

**期望行为**：只需要在一个标签页登录，其他标签页自动完成

## 核心设计

### 认证流程跟踪

**全局标记**：是否有认证流程正在进行

**第一个请求**：

- 检查：没有认证流程在进行
- 标记：认证流程开始
- 行动：重定向到 Logto（让它去登录）

**后续请求**：

- 检查：有认证流程在进行
- 行动：返回等待页面（建立 SSE 连接）

### 等待页面

**显示内容**：

- 加载动画（旋转圆环或脉冲效果）
- 主标题："正在登录..."
- 副标题："请在另一个标签页完成登录"
- 倒计时："已等待 15 秒"
- 按钮："等不及了？点击这里自己登录"

**技术实现**：

- 建立 SSE 连接：`/_oauth/wait`
- 收到 `authenticated` 事件 → 显示"✓ 登录成功" → 自动跳转
- 连接超时（30 分钟）→ 显示"等待超时，请点击按钮重试"

### SSE 事件广播

**登录成功时**：

- 创建 Session
- 清除认证流程标记
- 广播 SSE 事件：`authenticated`

**等待页面收到事件**：

- 显示成功提示
- 自动跳转回原页面

## 工作流程

### 正常流程

1. **app.com**（第1个请求）→ 重定向到 Logto
2. **bpp.com**（第2个请求）→ 返回等待页面，建立 SSE 连接
3. **cpp.com**（第3个请求）→ 返回等待页面，建立 SSE 连接
4. 用户在 app.com 的 Logto 页面登录 → auth 创建 Session → 广播 SSE 事件
5. bpp.com 和 cpp.com 收到事件 → 自动跳转回原页面

**结果**：用户只登录一次，所有标签页都完成认证

**关键点**：

- 第1个请求去 Logto（无论单标签页还是多标签页）
- 第2+个请求等待（只有多标签页才会有）
- 单标签页场景：第1个请求去 Logto，没有第2个请求，正常登录
- 多标签页场景：第1个去 Logto，第2、3个等待，登录后全部完成

### 自救机制

**如果用户不想等待**：

- 点击"自己去登录"按钮
- 关闭 SSE 连接
- 直接去 Logto（不管有没有其他流程在进行）

**如果多个标签页都去 Logto**：

- 每个标签页独立的 OAuth 流程（独立的 state 和 code）
- 第一个完成授权 → auth 创建 Session → 广播 SSE 事件
- 其他标签页：
  - 还在等待页面 → 收到 SSE 事件 → 自动跳转
  - 已在 Logto → 点授权 → callback 时检测到已登录 → 直接跳转

**关键点**：callback 时先检查是否已登录，已登录则跳过 code exchange，直接重定向

## 异常处理

### 用户关闭去 Logto 的标签页

- 等待页面继续 SSE 连接（最多 30 分钟）
- 超时后显示"等待超时，请点击按钮重试"
- 用户点击按钮 → 直接去 Logto
- 登录成功后，其他等待页面自动完成

### SSE 连接断开

- 自动重连（最多 3 次）
- 重连失败 → 显示"连接失败，请点击按钮重试"

### 多个标签页同时点"自己去登录"

- 都去 Logto，都显示授权页面
- 第一个点授权 → 创建 Session → 广播事件
- 其他标签页点授权 → callback 检测到已登录 → 直接跳转
- 不会有 code 重复使用问题（每个标签页的 code 都不同）
- 用户在第2、3个标签页都点"自己去登录"
- 第2个跳转回原页面 → 检查：第1个还没登录完 → 成为新的"第1个请求" → 去 Logto
- 第3个跳转回原页面 → 检查：有认证流程在进行 → 返回等待页面
- 或者：第1个已经登录完 → 第2、3个检测到已登录 → 直接通过

## 关键业务逻辑

### 认证流程跟踪器

**数据结构**：

- 是否有流程在进行：布尔值
- 开始时间：时间戳
- 超时时间：30 分钟

**操作**：

- 开始流程：设置标记，记录时间
- 结束流程：清除标记
- 检查流程：返回是否在进行中

### SSE 连接管理

**连接池**：维护所有等待页面的 SSE 连接

**广播事件**：登录成功时，向所有连接发送 `authenticated` 事件

**连接清理**：超时或断开时，自动清理连接

### Callback 处理

**检查顺序**：

1. 检查 AUTH_HOST Cookie，如果已登录 → 直接重定向（不 exchange code）
2. 如果未登录 → Exchange code → 创建 Session → 广播 SSE 事件 → 重定向

**优势**：

- 避免 code 重复使用
- 支持多个标签页同时授权（虽然设计上第1个去 Logto，但用户可能手动让多个都去）
- 第一个完成的创建 Session，后续的检测到已登录直接跳转

## 用户体验

### 最佳场景

- 用户只需在一个标签页登录
- 其他标签页实时收到通知，自动完成
- 无需手动刷新或重新打开

### 容错场景

- 用户可以随时点击"自己去登录"
- 多个标签页都去 Logto 也不会失败
- 超时后提供重试机制

### 视觉反馈

- 加载动画：让用户知道系统在工作
- 倒计时：让用户知道等了多久
- 成功提示：让用户知道登录完成
- 自救按钮：让用户有控制感

## 总结

**核心机制**：认证流程跟踪 + SSE 事件广播 + 等待页面

**用户体验**：只需登录一次，其他标签页自动完成

**容错能力**：支持自救、支持多标签页同时授权、支持超时重试

**技术优势**：SSE 实时通知、无需轮询、服务器压力小
